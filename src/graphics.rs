use core::ptr::write_volatile;

#[derive(Clone, Copy, Debug)]
pub struct Color {
    pub r: u8,
    pub g: u8,
    pub b: u8,
    pub a: u8,
}

impl Color {
    pub const fn new(r: u8, g: u8, b: u8) -> Self {
        Color { r, g, b, a: 255 }
    }
    
    pub const fn rgba(r: u8, g: u8, b: u8, a: u8) -> Self {
        Color { r, g, b, a }
    }
    
    // Convert to 32-bit RGBA format
    pub fn to_u32(self) -> u32 {
        ((self.a as u32) << 24) | 
        ((self.r as u32) << 16) | 
        ((self.g as u32) << 8) | 
        (self.b as u32)
    }
}

// Common colors
impl Color {
    pub const BLACK: Color = Color::new(0, 0, 0);
    pub const WHITE: Color = Color::new(255, 255, 255);
    pub const RED: Color = Color::new(255, 0, 0);
    pub const GREEN: Color = Color::new(0, 255, 0);
    pub const BLUE: Color = Color::new(0, 0, 255);
    pub const YELLOW: Color = Color::new(255, 255, 0);
    pub const CYAN: Color = Color::new(0, 255, 255);
    pub const MAGENTA: Color = Color::new(255, 0, 255);
    pub const GRAY: Color = Color::new(128, 128, 128);
    pub const LIGHT_GRAY: Color = Color::new(192, 192, 192);
    pub const DARK_GRAY: Color = Color::new(64, 64, 64);
}

pub struct Framebuffer {
    width: u32,
    height: u32,
    buffer: *mut u32,
    pitch: u32,
}

impl Framebuffer {
    // Create framebuffer using ramfb configuration
    pub fn new() -> Option<Self> {
        let (width, height) = crate::ramfb::get_framebuffer_size();
        let buffer = crate::ramfb::get_framebuffer_addr() as *mut u32;
        
        let fb = Framebuffer {
            width,
            height,
            buffer,
            pitch: width * 4, // 32 bits per pixel
        };
        
        // Test the framebuffer with our graphics
        fb.clear(Color::new(16, 32, 64)); // Dark blue
        fb.fill_rect(50, 50, 100, 80, Color::RED);
        fb.draw_circle(300, 200, 60, Color::YELLOW);
        fb.draw_string(60, 60, "Rust OS GUI!", Color::WHITE);
        
        Some(fb)
    }
    
    pub fn width(&self) -> u32 {
        self.width
    }
    
    pub fn height(&self) -> u32 {
        self.height
    }
    
    pub fn put_pixel(&self, x: u32, y: u32, color: Color) {
        if x >= self.width || y >= self.height {
            return;
        }
        
        let offset = y * (self.pitch / 4) + x;
        unsafe {
            write_volatile(self.buffer.add(offset as usize), color.to_u32());
        }
    }
    
    pub fn fill_rect(&self, x: u32, y: u32, width: u32, height: u32, color: Color) {
        for py in y..y + height {
            for px in x..x + width {
                self.put_pixel(px, py, color);
            }
        }
    }
    
    pub fn clear(&self, color: Color) {
        self.fill_rect(0, 0, self.width, self.height, color);
    }
    
    pub fn draw_line(&self, x1: u32, y1: u32, x2: u32, y2: u32, color: Color) {
        // Simple line drawing using Bresenham's algorithm
        let dx = if x2 > x1 { (x2 - x1) as i32 } else { (x1 - x2) as i32 };
        let dy = if y2 > y1 { (y2 - y1) as i32 } else { (y1 - y2) as i32 };
        let sx = if x1 < x2 { 1 } else { -1 };
        let sy = if y1 < y2 { 1 } else { -1 };
        let mut err = if dx > dy { dx } else { -dy } / 2;
        
        let mut x = x1 as i32;
        let mut y = y1 as i32;
        
        loop {
            if x >= 0 && y >= 0 {
                self.put_pixel(x as u32, y as u32, color);
            }
            
            if x == x2 as i32 && y == y2 as i32 {
                break;
            }
            
            let e2 = err;
            if e2 > -dx {
                err -= dy;
                x += sx;
            }
            if e2 < dy {
                err += dx;
                y += sy;
            }
        }
    }
    
    pub fn draw_circle(&self, cx: u32, cy: u32, radius: u32, color: Color) {
        let r = radius as i32;
        for y in (cy as i32 - r)..=(cy as i32 + r) {
            for x in (cx as i32 - r)..=(cx as i32 + r) {
                let dx = x - cx as i32;
                let dy = y - cy as i32;
                if dx * dx + dy * dy <= r * r {
                    if x >= 0 && y >= 0 {
                        self.put_pixel(x as u32, y as u32, color);
                    }
                }
            }
        }
    }
    
    // Simple 8x8 bitmap font (basic ASCII)
    const FONT_8X8: [[u8; 8]; 95] = [
        // Space (32)
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        // ! (33)
        [0x18, 0x3C, 0x3C, 0x18, 0x18, 0x00, 0x18, 0x00],
        // " (34)
        [0x36, 0x36, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
        // # (35)
        [0x36, 0x36, 0x7F, 0x36, 0x7F, 0x36, 0x36, 0x00],
        // $ (36)
        [0x0C, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x0C, 0x00],
        // % (37)
        [0x00, 0x63, 0x33, 0x18, 0x0C, 0x66, 0x63, 0x00],
        // & (38)
        [0x1C, 0x36, 0x1C, 0x6E, 0x3B, 0x33, 0x6E, 0x00],
        // ' (39)
        [0x06, 0x06, 0x03, 0x00, 0x00, 0x00, 0x00, 0x00],
        // ( (40)
        [0x18, 0x0C, 0x06, 0x06, 0x06, 0x0C, 0x18, 0x00],
        // ) (41)
        [0x06, 0x0C, 0x18, 0x18, 0x18, 0x0C, 0x06, 0x00],
        // * (42)
        [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00],
        // + (43)
        [0x00, 0x0C, 0x0C, 0x3F, 0x0C, 0x0C, 0x00, 0x00],
        // , (44)
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x06, 0x00],
        // - (45)
        [0x00, 0x00, 0x00, 0x3F, 0x00, 0x00, 0x00, 0x00],
        // . (46)
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x0C, 0x0C, 0x00],
        // / (47)
        [0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x01, 0x00],
        // 0 (48)
        [0x3E, 0x63, 0x73, 0x7B, 0x6F, 0x67, 0x3E, 0x00],
        // 1 (49)
        [0x0C, 0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x3F, 0x00],
        // 2 (50)
        [0x1E, 0x33, 0x30, 0x1C, 0x06, 0x33, 0x3F, 0x00],
        // 3 (51)
        [0x1E, 0x33, 0x30, 0x1C, 0x30, 0x33, 0x1E, 0x00],
        // 4 (52)
        [0x38, 0x3C, 0x36, 0x33, 0x7F, 0x30, 0x78, 0x00],
        // 5 (53)
        [0x3F, 0x03, 0x1F, 0x30, 0x30, 0x33, 0x1E, 0x00],
        // 6 (54)
        [0x1C, 0x06, 0x03, 0x1F, 0x33, 0x33, 0x1E, 0x00],
        // 7 (55)
        [0x3F, 0x33, 0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x00],
        // 8 (56)
        [0x1E, 0x33, 0x33, 0x1E, 0x33, 0x33, 0x1E, 0x00],
        // 9 (57)
        [0x1E, 0x33, 0x33, 0x3E, 0x30, 0x18, 0x0E, 0x00],
        // : (58)
        [0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x0C, 0x00],
        // ; (59)
        [0x00, 0x0C, 0x0C, 0x00, 0x00, 0x0C, 0x06, 0x00],
        // < (60)
        [0x18, 0x0C, 0x06, 0x03, 0x06, 0x0C, 0x18, 0x00],
        // = (61)
        [0x00, 0x00, 0x3F, 0x00, 0x00, 0x3F, 0x00, 0x00],
        // > (62)
        [0x06, 0x0C, 0x18, 0x30, 0x18, 0x0C, 0x06, 0x00],
        // ? (63)
        [0x1E, 0x33, 0x30, 0x18, 0x0C, 0x00, 0x0C, 0x00],
        // @ (64)
        [0x3E, 0x63, 0x7B, 0x7B, 0x7B, 0x03, 0x1E, 0x00],
        // A (65)
        [0x0C, 0x1E, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x00],
        // B (66)
        [0x3F, 0x66, 0x66, 0x3E, 0x66, 0x66, 0x3F, 0x00],
        // C (67)
        [0x3C, 0x66, 0x03, 0x03, 0x03, 0x66, 0x3C, 0x00],
        // D (68)
        [0x1F, 0x36, 0x66, 0x66, 0x66, 0x36, 0x1F, 0x00],
        // E (69)
        [0x7F, 0x46, 0x16, 0x1E, 0x16, 0x46, 0x7F, 0x00],
        // F (70)
        [0x7F, 0x46, 0x16, 0x1E, 0x16, 0x06, 0x0F, 0x00],
        // G (71)
        [0x3C, 0x66, 0x03, 0x03, 0x73, 0x66, 0x7C, 0x00],
        // H (72)
        [0x33, 0x33, 0x33, 0x3F, 0x33, 0x33, 0x33, 0x00],
        // I (73)
        [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],
        // J (74)
        [0x78, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E, 0x00],
        // K (75)
        [0x67, 0x66, 0x36, 0x1E, 0x36, 0x66, 0x67, 0x00],
        // L (76)
        [0x0F, 0x06, 0x06, 0x06, 0x46, 0x66, 0x7F, 0x00],
        // M (77)
        [0x63, 0x77, 0x7F, 0x7F, 0x6B, 0x63, 0x63, 0x00],
        // N (78)
        [0x63, 0x67, 0x6F, 0x7B, 0x73, 0x63, 0x63, 0x00],
        // O (79)
        [0x1C, 0x36, 0x63, 0x63, 0x63, 0x36, 0x1C, 0x00],
        // P (80)
        [0x3F, 0x66, 0x66, 0x3E, 0x06, 0x06, 0x0F, 0x00],
        // Q (81)
        [0x1E, 0x33, 0x33, 0x33, 0x3B, 0x1E, 0x38, 0x00],
        // R (82)
        [0x3F, 0x66, 0x66, 0x3E, 0x36, 0x66, 0x67, 0x00],
        // S (83)
        [0x1E, 0x33, 0x07, 0x0E, 0x38, 0x33, 0x1E, 0x00],
        // T (84)
        [0x3F, 0x2D, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],
        // U (85)
        [0x33, 0x33, 0x33, 0x33, 0x33, 0x33, 0x3F, 0x00],
        // V (86)
        [0x33, 0x33, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00],
        // W (87)
        [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00],
        // X (88)
        [0x63, 0x63, 0x36, 0x1C, 0x1C, 0x36, 0x63, 0x00],
        // Y (89)
        [0x33, 0x33, 0x33, 0x1E, 0x0C, 0x0C, 0x1E, 0x00],
        // Z (90)
        [0x7F, 0x63, 0x31, 0x18, 0x4C, 0x66, 0x7F, 0x00],
        // [ (91)
        [0x1E, 0x06, 0x06, 0x06, 0x06, 0x06, 0x1E, 0x00],
        // \ (92)
        [0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x40, 0x00],
        // ] (93)
        [0x1E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x1E, 0x00],
        // ^ (94)
        [0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00],
        // _ (95)
        [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF],
        // ` (96)
        [0x0C, 0x0C, 0x18, 0x00, 0x00, 0x00, 0x00, 0x00],
        // a (97)
        [0x00, 0x00, 0x1E, 0x30, 0x3E, 0x33, 0x6E, 0x00],
        // b (98)
        [0x07, 0x06, 0x06, 0x3E, 0x66, 0x66, 0x3B, 0x00],
        // c (99)
        [0x00, 0x00, 0x1E, 0x33, 0x03, 0x33, 0x1E, 0x00],
        // d (100)
        [0x38, 0x30, 0x30, 0x3e, 0x33, 0x33, 0x6E, 0x00],
        // e (101)
        [0x00, 0x00, 0x1E, 0x33, 0x3f, 0x03, 0x1E, 0x00],
        // f (102)
        [0x1C, 0x36, 0x06, 0x0f, 0x06, 0x06, 0x0F, 0x00],
        // g (103)
        [0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x1F],
        // h (104)
        [0x07, 0x06, 0x36, 0x6E, 0x66, 0x66, 0x67, 0x00],
        // i (105)
        [0x0C, 0x00, 0x0E, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],
        // j (106)
        [0x30, 0x00, 0x30, 0x30, 0x30, 0x33, 0x33, 0x1E],
        // k (107)
        [0x07, 0x06, 0x66, 0x36, 0x1E, 0x36, 0x67, 0x00],
        // l (108)
        [0x0E, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x1E, 0x00],
        // m (109)
        [0x00, 0x00, 0x33, 0x7F, 0x7F, 0x6B, 0x63, 0x00],
        // n (110)
        [0x00, 0x00, 0x1F, 0x33, 0x33, 0x33, 0x33, 0x00],
        // o (111)
        [0x00, 0x00, 0x1E, 0x33, 0x33, 0x33, 0x1E, 0x00],
        // p (112)
        [0x00, 0x00, 0x3B, 0x66, 0x66, 0x3E, 0x06, 0x0F],
        // q (113)
        [0x00, 0x00, 0x6E, 0x33, 0x33, 0x3E, 0x30, 0x78],
        // r (114)
        [0x00, 0x00, 0x3B, 0x6E, 0x66, 0x06, 0x0F, 0x00],
        // s (115)
        [0x00, 0x00, 0x3E, 0x03, 0x1E, 0x30, 0x1F, 0x00],
        // t (116)
        [0x08, 0x0C, 0x3E, 0x0C, 0x0C, 0x2C, 0x18, 0x00],
        // u (117)
        [0x00, 0x00, 0x33, 0x33, 0x33, 0x33, 0x6E, 0x00],
        // v (118)
        [0x00, 0x00, 0x33, 0x33, 0x33, 0x1E, 0x0C, 0x00],
        // w (119)
        [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00],
        // x (120)
        [0x00, 0x00, 0x63, 0x36, 0x1C, 0x36, 0x63, 0x00],
        // y (121)
        [0x00, 0x00, 0x33, 0x33, 0x33, 0x3E, 0x30, 0x1F],
        // z (122)
        [0x00, 0x00, 0x3F, 0x19, 0x0C, 0x26, 0x3F, 0x00],
        // { (123)
        [0x38, 0x0C, 0x0C, 0x07, 0x0C, 0x0C, 0x38, 0x00],
        // | (124)
        [0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00],
        // } (125)
        [0x07, 0x0C, 0x0C, 0x38, 0x0C, 0x0C, 0x07, 0x00],
        // ~ (126)
        [0x6E, 0x3B, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00],
    ];
    
    pub fn draw_char(&self, x: u32, y: u32, ch: char, color: Color) {
        let char_code = ch as usize;
        if char_code < 32 || char_code > 126 {
            return; // Unsupported character
        }
        
        let font_data = &Self::FONT_8X8[char_code - 32];
        
        for row in 0..8 {
            let byte = font_data[row];
            for col in 0..8 {
                if (byte >> (7 - col)) & 1 == 1 {
                    self.put_pixel(x + col, y + row as u32, color);
                }
            }
        }
    }
    
    pub fn draw_string(&self, x: u32, y: u32, text: &str, color: Color) {
        let mut px = x;
        for ch in text.chars() {
            if ch == '\n' {
                // Move to next line
                return; // For now, don't handle newlines
            }
            self.draw_char(px, y, ch, color);
            px += 8; // Move to next character position
        }
    }
}

static mut FRAMEBUFFER: Option<Framebuffer> = None;

pub fn init() -> Result<(), &'static str> {
    unsafe {
        FRAMEBUFFER = Framebuffer::new();
        if FRAMEBUFFER.is_some() {
            crate::uart::Uart::new(0x0900_0000).puts("Framebuffer initialized (800x600)\n");
            
            // Test the framebuffer with some colors
            if let Some(ref fb) = FRAMEBUFFER {
                fb.clear(Color::BLUE);
                fb.fill_rect(100, 100, 200, 100, Color::RED);
                fb.draw_circle(400, 300, 50, Color::YELLOW);
                fb.draw_string(50, 50, "Rust OS GUI!", Color::WHITE);
            }
            
            Ok(())
        } else {
            Err("Failed to initialize framebuffer")
        }
    }
}

pub fn get_framebuffer() -> Option<&'static Framebuffer> {
    unsafe { FRAMEBUFFER.as_ref() }
}

pub fn get_framebuffer_mut() -> Option<&'static mut Framebuffer> {
    unsafe { FRAMEBUFFER.as_mut() }
}
// Framebuffer driver for post-UEFI graphics

use core::ptr;

/// Framebuffer information preserved from UEFI
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct FramebufferInfo {
    pub base_address: u64,
    pub size: usize,
    pub width: u32,
    pub height: u32,
    pub pixels_per_scanline: u32,
    pub pixel_format: PixelFormat,
}

#[repr(u32)]
#[derive(Debug, Clone, Copy)]
pub enum PixelFormat {
    Rgb = 0,
    Bgr = 1,
    Bitmask = 2,
    BltOnly = 3,
}

static mut FRAMEBUFFER: Option<Framebuffer> = None;

struct Framebuffer {
    base: *mut u32,
    width: u32,
    height: u32,
    stride: u32,
    pixel_format: PixelFormat,
}

impl Framebuffer {
    unsafe fn put_pixel(&mut self, x: u32, y: u32, color: u32) {
        if x >= self.width || y >= self.height {
            return;
        }
        
        let offset = (y * self.stride + x) as isize;
        let pixel = self.base.offset(offset);
        
        // Convert color based on pixel format
        let color_value = match self.pixel_format {
            PixelFormat::Rgb => color,
            PixelFormat::Bgr => {
                let r = (color >> 16) & 0xFF;
                let g = (color >> 8) & 0xFF;
                let b = color & 0xFF;
                (b << 16) | (g << 8) | r
            }
            _ => color,
        };
        
        ptr::write_volatile(pixel, color_value);
    }
    
    fn fill_rect(&mut self, x: u32, y: u32, width: u32, height: u32, color: u32) {
        for dy in 0..height {
            for dx in 0..width {
                unsafe {
                    self.put_pixel(x + dx, y + dy, color);
                }
            }
        }
    }
}

/// Initialize framebuffer with info from UEFI
pub fn init(info: &FramebufferInfo) {
    // Don't initialize if we don't have a valid framebuffer address
    if info.base_address == 0 {
        return;
    }
    
    unsafe {
        FRAMEBUFFER = Some(Framebuffer {
            base: info.base_address as *mut u32,
            width: info.width,
            height: info.height,
            stride: info.pixels_per_scanline,
            pixel_format: info.pixel_format,
        });
    }
}

/// Clear the screen with a color
pub fn clear_screen(color: u32) {
    unsafe {
        if let Some(ref mut fb) = FRAMEBUFFER {
            fb.fill_rect(0, 0, fb.width, fb.height, color);
        }
    }
}

/// Simple 8x8 bitmap font for basic text rendering
const FONT_8X8: [[u8; 8]; 98] = [
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0 - null
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 1
    // ... would include full font data
    // For now, just include some letters for demo
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // space (32)
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00], // !
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // ... filler
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // ... more filler
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    // Numbers 0-9 (48-57)
    [0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00], // 0
    [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // 1
    [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00], // 2
    [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00], // 3
    [0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00], // 4
    [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00], // 5
    [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00], // 6
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00], // 7
    [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00], // 8
    [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00], // 9
    // ... more filler to get to uppercase letters
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    // A-Z (65-90)
    [0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // A
    [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00], // B
    [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00], // C
    [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00], // D
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00], // E
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00], // F
    [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00], // G
    [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // H
    [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // I
    [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00], // J
    [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00], // K
    [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00], // L
    [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00], // M
    [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00], // N
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // O
    [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00], // P
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00], // Q
    [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00], // R
    [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00], // S
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // T
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // U
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00], // V
    [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00], // W
    [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00], // X
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00], // Y
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00], // Z
    // ... rest would be lowercase and symbols
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    // a-z (97-122) - simplified, using uppercase patterns
    [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00], // a
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00], // b
    [0x00, 0x00, 0x3C, 0x60, 0x60, 0x60, 0x3C, 0x00], // c
    [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00], // d
    [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00], // e
    [0x0E, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00], // f
    [0x00, 0x00, 0x3E, 0x66, 0x3E, 0x06, 0x7C, 0x00], // g
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // h
    [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00], // i
    [0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00], // j
    [0x60, 0x60, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x00], // k
    [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // l
    [0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00], // m
    [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // n
    [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00], // o
    [0x00, 0x00, 0x7C, 0x66, 0x7C, 0x60, 0x60, 0x00], // p
    [0x00, 0x00, 0x3E, 0x66, 0x3E, 0x06, 0x06, 0x00], // q
    [0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00], // r
    [0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00], // s
    [0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x0E, 0x00], // t
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00], // u
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00], // v
    [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00], // w
    [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00], // x
    [0x00, 0x00, 0x66, 0x66, 0x3E, 0x06, 0x7C, 0x00], // y
    [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00], // z
    // Fill rest with empty
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], 
];

fn draw_char(x: u32, y: u32, ch: u8, color: u32) {
    unsafe {
        if let Some(ref mut fb) = FRAMEBUFFER {
            let char_data = if ch < 98 {
                FONT_8X8[ch as usize]
            } else {
                FONT_8X8[0] // Use null character for unknown
            };
            
            for (row, &byte) in char_data.iter().enumerate() {
                for col in 0..8 {
                    if byte & (1 << (7 - col)) != 0 {
                        fb.put_pixel(x + col, y + row as u32, color);
                    }
                }
            }
        }
    }
}

/// Draw a string at the specified position
pub fn draw_string(x: u32, y: u32, text: &str, color: u32) {
    let mut cur_x = x;
    for ch in text.bytes() {
        if ch == b'\n' {
            // Newline - move to next line
            return; // For simplicity, just stop at newline
        }
        draw_char(cur_x, y, ch, color);
        cur_x += 8; // Move to next character position
    }
}
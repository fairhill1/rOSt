// Framebuffer driver for post-UEFI graphics

use core::ptr;

/// Framebuffer information preserved from UEFI
#[repr(C)]
#[derive(Debug, Clone, Copy)]
pub struct FramebufferInfo {
    pub base_address: u64,
    pub size: usize,
    pub width: u32,
    pub height: u32,
    pub pixels_per_scanline: u32,
    pub pixel_format: PixelFormat,
}

#[repr(u32)]
#[derive(Debug, Clone, Copy)]
pub enum PixelFormat {
    Rgb = 0,
    Bgr = 1,
    Bitmask = 2,
    BltOnly = 3,
}

static mut FRAMEBUFFER: Option<Framebuffer> = None;
static mut BACK_BUFFER: Option<*mut u32> = None; // Offscreen buffer for double buffering
static mut FRONT_BUFFER: *mut u32 = core::ptr::null_mut(); // Actual screen buffer
static mut SCREEN_WIDTH: u32 = 0;
static mut SCREEN_HEIGHT: u32 = 0;
static mut SCREEN_STRIDE: u32 = 0;

// Mouse cursor state
static mut MOUSE_CURSOR: MouseCursor = MouseCursor { x: 400, y: 300, prev_x: 400, prev_y: 300 };
static mut MOUSE_CURSOR_BACKGROUND: [u32; 16 * 16] = [0; 256];

#[derive(Clone, Copy)]
struct MouseCursor {
    x: i32,
    y: i32,
    prev_x: i32,
    prev_y: i32,
}

struct Framebuffer {
    base: *mut u32,
    width: u32,
    height: u32,
    stride: u32,
    pixel_format: PixelFormat,
}

impl Framebuffer {
    unsafe fn put_pixel(&mut self, x: u32, y: u32, color: u32) {
        if x >= self.width || y >= self.height {
            return;
        }
        
        let offset = (y * self.stride + x) as isize;
        let pixel = self.base.offset(offset);
        
        // Convert color based on pixel format
        let color_value = match self.pixel_format {
            PixelFormat::Rgb => color,
            PixelFormat::Bgr => {
                let r = (color >> 16) & 0xFF;
                let g = (color >> 8) & 0xFF;
                let b = color & 0xFF;
                (b << 16) | (g << 8) | r
            }
            _ => color,
        };
        
        ptr::write_volatile(pixel, color_value);
    }

    unsafe fn get_pixel(&self, x: u32, y: u32) -> u32 {
        if x >= self.width || y >= self.height {
            return 0; // Return black for out-of-bounds
        }
        
        let offset = (y * self.stride + x) as isize;
        let pixel = self.base.offset(offset);
        
        ptr::read_volatile(pixel)
    }
    
    fn fill_rect(&mut self, x: u32, y: u32, width: u32, height: u32, color: u32) {
        for dy in 0..height {
            for dx in 0..width {
                unsafe {
                    self.put_pixel(x + dx, y + dy, color);
                }
            }
        }
    }
}

/// Initialize framebuffer with info from UEFI
pub fn init(info: &FramebufferInfo) {
    // Don't initialize if we don't have a valid framebuffer address
    if info.base_address == 0 {
        return;
    }

    unsafe {
        SCREEN_WIDTH = info.width;
        SCREEN_HEIGHT = info.height;
        SCREEN_STRIDE = info.pixels_per_scanline;
        FRONT_BUFFER = info.base_address as *mut u32;

        // Allocate back buffer for double buffering
        let buffer_size = (info.height * info.pixels_per_scanline) as usize;
        let buffer_opt = crate::kernel::memory::allocate_pages(
            (buffer_size * 4 + 4095) / 4096 // Number of 4KB pages needed
        );

        if let Some(buffer_addr) = buffer_opt {
            let buffer_ptr = buffer_addr as *mut u32;
            BACK_BUFFER = Some(buffer_ptr);

            // All drawing goes to back buffer
            FRAMEBUFFER = Some(Framebuffer {
                base: buffer_ptr,
                width: info.width,
                height: info.height,
                stride: info.pixels_per_scanline,
                pixel_format: info.pixel_format,
            });
        } else {
            // Fallback: draw directly to screen (no double buffering)
            BACK_BUFFER = None;
            FRAMEBUFFER = Some(Framebuffer {
                base: info.base_address as *mut u32,
                width: info.width,
                height: info.height,
                stride: info.pixels_per_scanline,
                pixel_format: info.pixel_format,
            });
        }
    }
}

/// Swap buffers - copy back buffer to front buffer (screen)
/// This is the magic that eliminates flicker!
pub fn swap_buffers() {
    unsafe {
        if let Some(back) = BACK_BUFFER {
            if !FRONT_BUFFER.is_null() {
                // Fast copy from back buffer to front buffer
                let size = (SCREEN_HEIGHT * SCREEN_STRIDE) as usize;
                core::ptr::copy_nonoverlapping(back, FRONT_BUFFER, size);
            }
        }
        // If no back buffer, we're drawing directly to screen (no swap needed)
    }
}

/// Clear the screen with a color
pub fn clear_screen(color: u32) {
    unsafe {
        if let Some(ref mut fb) = FRAMEBUFFER {
            fb.fill_rect(0, 0, fb.width, fb.height, color);
        }
    }
}

/// Simple 8x8 bitmap font for basic text rendering
/// Covers ASCII 0-127 with glyphs for 0-9, A-Z, a-z
const FONT_8X8: [[u8; 8]; 128] = [
    // Control characters 0-31 (blank)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 0
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 1
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 2
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 3
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 4
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 5
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 6
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 7
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 8 (note: backspace handled in console)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 9
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 10 (note: newline handled in console)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 11
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 12
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 13 (note: carriage return handled in console)
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 14
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 15
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 16
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 17
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 18
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 19
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 20
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 21
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 22
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 23
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 24
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 25
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 26
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 27
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 28
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 29
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 30
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 31
    // Printable characters start at 32
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 32 - space
    [0x18, 0x18, 0x18, 0x18, 0x18, 0x00, 0x18, 0x00], // 33 - !
    [0x66, 0x66, 0x66, 0x00, 0x00, 0x00, 0x00, 0x00], // 34 - "
    [0x6C, 0x6C, 0xFE, 0x6C, 0xFE, 0x6C, 0x6C, 0x00], // 35 - #
    [0x18, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x18, 0x00], // 36 - $
    [0x62, 0x66, 0x0C, 0x18, 0x30, 0x66, 0x46, 0x00], // 37 - %
    [0x3C, 0x66, 0x3C, 0x38, 0x67, 0x66, 0x3F, 0x00], // 38 - &
    [0x0C, 0x18, 0x30, 0x00, 0x00, 0x00, 0x00, 0x00], // 39 - '
    [0x0C, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0C, 0x00], // 40 - (
    [0x30, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x30, 0x00], // 41 - )
    [0x00, 0x66, 0x3C, 0xFF, 0x3C, 0x66, 0x00, 0x00], // 42 - *
    [0x00, 0x18, 0x18, 0x7E, 0x18, 0x18, 0x00, 0x00], // 43 - +
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x30], // 44 - ,
    [0x00, 0x00, 0x00, 0x7E, 0x00, 0x00, 0x00, 0x00], // 45 - -
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x18, 0x18, 0x00], // 46 - .
    [0x00, 0x03, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x00], // 47 - / 
    // Numbers 0-9 (48-57)
    [0x3C, 0x66, 0x6E, 0x76, 0x66, 0x66, 0x3C, 0x00], // 0
    [0x18, 0x38, 0x18, 0x18, 0x18, 0x18, 0x7E, 0x00], // 1
    [0x3C, 0x66, 0x06, 0x0C, 0x30, 0x60, 0x7E, 0x00], // 2
    [0x3C, 0x66, 0x06, 0x1C, 0x06, 0x66, 0x3C, 0x00], // 3
    [0x0C, 0x1C, 0x3C, 0x6C, 0x7E, 0x0C, 0x0C, 0x00], // 4
    [0x7E, 0x60, 0x7C, 0x06, 0x06, 0x66, 0x3C, 0x00], // 5
    [0x3C, 0x66, 0x60, 0x7C, 0x66, 0x66, 0x3C, 0x00], // 6
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x30, 0x30, 0x00], // 7
    [0x3C, 0x66, 0x66, 0x3C, 0x66, 0x66, 0x3C, 0x00], // 8
    [0x3C, 0x66, 0x66, 0x3E, 0x06, 0x66, 0x3C, 0x00], // 9
    // : ; < = > ? @ (58-64)
    [0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x00, 0x00], // 58 - :
    [0x00, 0x18, 0x18, 0x00, 0x18, 0x18, 0x30, 0x00], // 59 - ;
    [0x0C, 0x18, 0x30, 0x60, 0x30, 0x18, 0x0C, 0x00], // 60 - <
    [0x00, 0x00, 0x7E, 0x00, 0x7E, 0x00, 0x00, 0x00], // 61 - =
    [0x30, 0x18, 0x0C, 0x06, 0x0C, 0x18, 0x30, 0x00], // 62 - >
    [0x3C, 0x66, 0x06, 0x0C, 0x18, 0x00, 0x18, 0x00], // 63 - ?
    [0x3C, 0x66, 0x6E, 0x6E, 0x60, 0x62, 0x3C, 0x00], // 64 - @ 
    // A-Z (65-90)
    [0x18, 0x3C, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // A
    [0x7C, 0x66, 0x66, 0x7C, 0x66, 0x66, 0x7C, 0x00], // B
    [0x3C, 0x66, 0x60, 0x60, 0x60, 0x66, 0x3C, 0x00], // C
    [0x78, 0x6C, 0x66, 0x66, 0x66, 0x6C, 0x78, 0x00], // D
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x7E, 0x00], // E
    [0x7E, 0x60, 0x60, 0x78, 0x60, 0x60, 0x60, 0x00], // F
    [0x3C, 0x66, 0x60, 0x6E, 0x66, 0x66, 0x3C, 0x00], // G
    [0x66, 0x66, 0x66, 0x7E, 0x66, 0x66, 0x66, 0x00], // H
    [0x3C, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // I
    [0x1E, 0x0C, 0x0C, 0x0C, 0x0C, 0x6C, 0x38, 0x00], // J
    [0x66, 0x6C, 0x78, 0x70, 0x78, 0x6C, 0x66, 0x00], // K
    [0x60, 0x60, 0x60, 0x60, 0x60, 0x60, 0x7E, 0x00], // L
    [0x63, 0x77, 0x7F, 0x6B, 0x63, 0x63, 0x63, 0x00], // M
    [0x66, 0x76, 0x7E, 0x7E, 0x6E, 0x66, 0x66, 0x00], // N
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // O
    [0x7C, 0x66, 0x66, 0x7C, 0x60, 0x60, 0x60, 0x00], // P
    [0x3C, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x0E, 0x00], // Q
    [0x7C, 0x66, 0x66, 0x7C, 0x78, 0x6C, 0x66, 0x00], // R
    [0x3C, 0x66, 0x60, 0x3C, 0x06, 0x66, 0x3C, 0x00], // S
    [0x7E, 0x18, 0x18, 0x18, 0x18, 0x18, 0x18, 0x00], // T
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x00], // U
    [0x66, 0x66, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00], // V
    [0x63, 0x63, 0x63, 0x6B, 0x7F, 0x77, 0x63, 0x00], // W
    [0x66, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x66, 0x00], // X
    [0x66, 0x66, 0x66, 0x3C, 0x18, 0x18, 0x18, 0x00], // Y
    [0x7E, 0x06, 0x0C, 0x18, 0x30, 0x60, 0x7E, 0x00], // Z (90)
    // [ \ ] ^ _ ` (91-96)
    [0x3C, 0x30, 0x30, 0x30, 0x30, 0x30, 0x3C, 0x00], // 91 - [
    [0x00, 0x60, 0x30, 0x18, 0x0C, 0x06, 0x03, 0x00], // 92 - \
    [0x3C, 0x0C, 0x0C, 0x0C, 0x0C, 0x0C, 0x3C, 0x00], // 93 - ]
    [0x08, 0x1C, 0x36, 0x63, 0x00, 0x00, 0x00, 0x00], // 94 - ^
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0xFF, 0x00], // 95 - _
    [0x30, 0x18, 0x0C, 0x00, 0x00, 0x00, 0x00, 0x00], // 96 - ` 
    // a-z (97-122) - simplified, using uppercase patterns
    [0x00, 0x00, 0x3C, 0x06, 0x3E, 0x66, 0x3E, 0x00], // a
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x7C, 0x00], // b
    [0x00, 0x00, 0x3C, 0x60, 0x60, 0x60, 0x3C, 0x00], // c
    [0x06, 0x06, 0x3E, 0x66, 0x66, 0x66, 0x3E, 0x00], // d
    [0x00, 0x00, 0x3C, 0x66, 0x7E, 0x60, 0x3C, 0x00], // e
    [0x0E, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x18, 0x00], // f
    [0x00, 0x00, 0x3E, 0x66, 0x3E, 0x06, 0x7C, 0x00], // g
    [0x60, 0x60, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // h
    [0x18, 0x00, 0x38, 0x18, 0x18, 0x18, 0x3C, 0x00], // i
    [0x06, 0x00, 0x06, 0x06, 0x06, 0x66, 0x3C, 0x00], // j
    [0x60, 0x60, 0x6C, 0x78, 0x78, 0x6C, 0x66, 0x00], // k
    [0x38, 0x18, 0x18, 0x18, 0x18, 0x18, 0x3C, 0x00], // l
    [0x00, 0x00, 0x66, 0x7F, 0x7F, 0x6B, 0x63, 0x00], // m
    [0x00, 0x00, 0x7C, 0x66, 0x66, 0x66, 0x66, 0x00], // n
    [0x00, 0x00, 0x3C, 0x66, 0x66, 0x66, 0x3C, 0x00], // o
    [0x00, 0x00, 0x7C, 0x66, 0x7C, 0x60, 0x60, 0x00], // p
    [0x00, 0x00, 0x3E, 0x66, 0x3E, 0x06, 0x06, 0x00], // q
    [0x00, 0x00, 0x7C, 0x66, 0x60, 0x60, 0x60, 0x00], // r
    [0x00, 0x00, 0x3E, 0x60, 0x3C, 0x06, 0x7C, 0x00], // s
    [0x18, 0x18, 0x7E, 0x18, 0x18, 0x18, 0x0E, 0x00], // t
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x66, 0x3E, 0x00], // u
    [0x00, 0x00, 0x66, 0x66, 0x66, 0x3C, 0x18, 0x00], // v
    [0x00, 0x00, 0x63, 0x6B, 0x7F, 0x7F, 0x36, 0x00], // w
    [0x00, 0x00, 0x66, 0x3C, 0x18, 0x3C, 0x66, 0x00], // x
    [0x00, 0x00, 0x66, 0x66, 0x3E, 0x06, 0x7C, 0x00], // y
    [0x00, 0x00, 0x7E, 0x0C, 0x18, 0x30, 0x7E, 0x00], // z (122)
    // { | } ~ (123-126)
    [0x0E, 0x18, 0x30, 0x30, 0x30, 0x18, 0x0E, 0x00], // 123 - {
    [0x18, 0x18, 0x18, 0x00, 0x18, 0x18, 0x18, 0x00], // 124 - |
    [0x70, 0x18, 0x0C, 0x0C, 0x0C, 0x18, 0x70, 0x00], // 125 - }
    [0x76, 0xDC, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 126 - ~
    [0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00, 0x00], // 127
];

fn draw_char(x: u32, y: u32, ch: u8, color: u32) {
    unsafe {
        if let Some(ref mut fb) = FRAMEBUFFER {
            let char_data = if ch < 128 {
                FONT_8X8[ch as usize]
            } else {
                FONT_8X8[0] // Use null character for unknown
            };

            // Scale 2x - each pixel in the 8x8 font becomes a 2x2 block
            for (row, &byte) in char_data.iter().enumerate() {
                for col in 0..8 {
                    if byte & (1 << (7 - col)) != 0 {
                        // Draw 2x2 pixel block
                        let px = x + col * 2;
                        let py = y + row as u32 * 2;
                        fb.put_pixel(px, py, color);
                        fb.put_pixel(px + 1, py, color);
                        fb.put_pixel(px, py + 1, color);
                        fb.put_pixel(px + 1, py + 1, color);
                    }
                }
            }
        }
    }
}

/// Draw a single pixel
pub fn draw_pixel(x: u32, y: u32, color: u32) {
    unsafe {
        if let Some(ref mut fb) = FRAMEBUFFER {
            fb.put_pixel(x, y, color);
        }
    }
}

/// Draw a string at the specified position
pub fn draw_string(x: u32, y: u32, text: &str, color: u32) {
    let mut cur_x = x;
    for ch in text.bytes() {
        if ch == b'\n' {
            // Newline - move to next line
            return; // For simplicity, just stop at newline
        }
        draw_char(cur_x, y, ch, color);
        cur_x += 16; // Move to next character position (scaled 2x: 8*2=16)
    }
}

// Mouse cursor arrow bitmap (16x16)
const CURSOR_ARROW: [[u8; 16]; 16] = [
    [1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,2,1,0,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,2,2,1,0,0,0,0,0,0,0,0,0,0,0,0],
    [1,2,2,2,1,0,0,0,0,0,0,0,0,0,0,0],
    [1,2,2,2,2,1,0,0,0,0,0,0,0,0,0,0],
    [1,2,2,2,2,2,1,0,0,0,0,0,0,0,0,0],
    [1,2,2,2,2,2,2,1,0,0,0,0,0,0,0,0],
    [1,2,2,2,2,2,2,2,1,0,0,0,0,0,0,0],
    [1,2,2,2,2,2,2,2,2,1,0,0,0,0,0,0],
    [1,2,2,2,2,2,1,1,1,1,1,0,0,0,0,0],
    [1,2,2,1,2,2,1,0,0,0,0,0,0,0,0,0],
    [1,2,1,0,1,2,2,1,0,0,0,0,0,0,0,0],
    [1,1,0,0,1,2,2,1,0,0,0,0,0,0,0,0],
    [1,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0],
    [0,0,0,0,0,1,2,2,1,0,0,0,0,0,0,0],
];

/// Draw the mouse cursor at its current position, handling background restoration.
pub fn draw_cursor() {
    unsafe {
        if let Some(ref mut fb) = FRAMEBUFFER {
            // 1. Restore the background at the previous cursor position.
            for y in 0..16 {
                for x in 0..16 {
                    let screen_x = MOUSE_CURSOR.prev_x + x as i32;
                    let screen_y = MOUSE_CURSOR.prev_y + y as i32;
                    if screen_x >= 0 && screen_x < fb.width as i32 && screen_y >= 0 && screen_y < fb.height as i32 {
                        fb.put_pixel(screen_x as u32, screen_y as u32, MOUSE_CURSOR_BACKGROUND[y * 16 + x]);
                    }
                }
            }

            // 2. Save the background at the new cursor position.
            for y in 0..16 {
                for x in 0..16 {
                    let screen_x = MOUSE_CURSOR.x + x as i32;
                    let screen_y = MOUSE_CURSOR.y + y as i32;
                    if screen_x >= 0 && screen_x < fb.width as i32 && screen_y >= 0 && screen_y < fb.height as i32 {
                        MOUSE_CURSOR_BACKGROUND[y * 16 + x] = fb.get_pixel(screen_x as u32, screen_y as u32);
                    }
                }
            }

            // 3. Draw the new cursor.
            for y in 0..16 {
                for x in 0..16 {
                    let screen_x = MOUSE_CURSOR.x + x as i32;
                    let screen_y = MOUSE_CURSOR.y + y as i32;

                    if screen_x >= 0 && screen_x < fb.width as i32 && screen_y >= 0 && screen_y < fb.height as i32 {
                        match CURSOR_ARROW[y as usize][x as usize] {
                            1 => fb.put_pixel(screen_x as u32, screen_y as u32, 0xFF000000), // Black outline
                            2 => fb.put_pixel(screen_x as u32, screen_y as u32, 0xFFFFFFFF), // White fill
                            _ => (), // Transparent
                        }
                    }
                }
            }

            // 4. Update previous position for the next frame.
            MOUSE_CURSOR.prev_x = MOUSE_CURSOR.x;
            MOUSE_CURSOR.prev_y = MOUSE_CURSOR.y;
        }
    }
}

/// Move the mouse cursor by delta values
pub fn move_cursor(dx: i8, dy: i8) {
    unsafe {
        // Update to new position
        MOUSE_CURSOR.x += dx as i32;
        MOUSE_CURSOR.y += dy as i32;

        // Clamp to screen bounds to prevent cursor from going off-screen
        if let Some(ref fb) = FRAMEBUFFER {
            if MOUSE_CURSOR.x < 0 { MOUSE_CURSOR.x = 0; }
            if MOUSE_CURSOR.y < 0 { MOUSE_CURSOR.y = 0; }
            if MOUSE_CURSOR.x >= fb.width as i32 - 16 { MOUSE_CURSOR.x = fb.width as i32 - 16; }
            if MOUSE_CURSOR.y >= fb.height as i32 - 16 { MOUSE_CURSOR.y = fb.height as i32 - 16; }
        }
    }
}

/// Get the current cursor position
pub fn get_cursor_pos() -> (i32, i32) {
    unsafe {
        (MOUSE_CURSOR.x, MOUSE_CURSOR.y)
    }
}

/// Set the cursor position directly
pub fn set_cursor_pos(x: i32, y: i32) {
    unsafe {
        MOUSE_CURSOR.x = x;
        MOUSE_CURSOR.y = y;

        // Clamp to screen bounds
        if let Some(ref fb) = FRAMEBUFFER {
            if MOUSE_CURSOR.x < 0 { MOUSE_CURSOR.x = 0; }
            if MOUSE_CURSOR.y < 0 { MOUSE_CURSOR.y = 0; }
            if MOUSE_CURSOR.x >= fb.width as i32 { MOUSE_CURSOR.x = fb.width as i32 - 1; }
            if MOUSE_CURSOR.y >= fb.height as i32 { MOUSE_CURSOR.y = fb.height as i32 - 1; }
        }
    }
}

/// Get screen dimensions
pub fn get_screen_dimensions() -> (u32, u32) {
    unsafe {
        (SCREEN_WIDTH, SCREEN_HEIGHT)
    }
}

/// Get direct access to the back buffer for custom rendering
pub fn get_back_buffer() -> &'static mut [u32] {
    unsafe {
        if let Some(back) = BACK_BUFFER {
            let size = (SCREEN_HEIGHT * SCREEN_STRIDE) as usize;
            core::slice::from_raw_parts_mut(back, size)
        } else if let Some(ref fb) = FRAMEBUFFER {
            // Fallback to direct framebuffer if no back buffer
            let size = (SCREEN_HEIGHT * SCREEN_STRIDE) as usize;
            core::slice::from_raw_parts_mut(fb.base, size)
        } else {
            // Return empty slice if no framebuffer is initialized
            &mut []
        }
    }
}